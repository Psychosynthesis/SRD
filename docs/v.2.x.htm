<!doctype html>
<html lang="en" class="no-js">
<head>
    <meta charset="utf-8">
    <title>Sphinx v.2 Russian Docs</title>
    <style>
        body { max-width: 1000px; margin: 0 auto; margin-bottom: 100px; }
    </style>
</head>
<body>
<h2>Русская документация по поисковому движку Sphinx (Sphinx Russian Docs)</h2>
<b>Sphinx v.2</b>
<br/><br/>
Я не знаю по какой причине, но авторы Sphinx не удосужились написать для него нормальную русскоязычную документацию. Здесь переведена официальная документация для второй версии Sphinx.
<br/><br/>
<br/><br/>

<h2>1.1. Введение</h2>
Sphinx это поисковый движок, обеспечивающий &laquo;полнотекстовый&raquo; поиск.
Данное ПО распространяется под лицензией GPL version 2.
Коммерческая лицензия (например для использования в качестве части ваших продуктов) доступна по запросу.
<br /><br />
Технически Sphinx это независимое приложение, обеспечивающее быстрый и точный &laquo;полнотекстовый&raquo; поиск [по БД] для ваших приложений.
<br /><br />
Хотя Sphinx был разработан специально для интеграции с SQL-базами данных, и обеспечивания доступности этих данных посредством скриптовых языков,
тем не менее, он не требует какой-либо конкретной базы данных для функционирования.
<br /><br />
Приложения могут общаться со службой Sphinx (searchd) используя один из трёх способов:<br/>
<ul>
    <li>Через собственную реализацию MySQL-совместимого сетевого протокола (используя подмножество SQL под названием SphinxQL) - это рекомендуемый способ</li>
    <li>Через встроенный API поиска (SphinxAPI)</li>
    <li>Через сервер MySQL с отдельно подключаемым хранилищем (SphinxSE)</li>
</ul>
<br/><br/>
Оффициальные реализации SphinxAPI для PHP, Perl, Python, Ruby и Java включены в распространяемый пакет.
API весьма легковесно, поэтому портирование его под новые языки занимает всего несколько часов или дней.
Сторонние реализации API и плагины существуют для Perl, C#, Haskell, Ruby-on-Rails и, вероятно, также для других языков и фреймворков.
<br/><br/>
Начиная с версии 1.10-beta, Sphinx поддерживает два разных типа индекса: индексы типа "disk" и "realtime" (RT) индексы. Предыдущие версии поддерживали только дисковые disk-индексы.
<br/><br/>
Вот некоторые различия между этими типами индексов:<br/>
<ul>
    <li>Disk-индексы поддерживают перестроение полнотекстового индекса в режиме онлайн,но онлайн-обновления могут выполняться только для нетекстовых (атрибуты) данных.
    Данные могут быть загружены в disk-индексы с помощью т.н. &laquo;источника данных&raquo;.
    Встроенные источники могут получать данные непосредственно из MySQL, PostgreSQL, MSSQL, ODBC-совместимой базы данных (Oracle и т. Д.), или из TSV-pipe или в произвольном XML-формате.
    Добавление новых драйверов источников данных (например, для поддержки других СУБД) максимально просто.</li>

    <li>RT-индексы допускают онлайн обновления полнотекстового индекса, однако, начиная с v.1.10-бета, могут быть заполнены только с помощью SphinxQL.</li>
</ul>
<br/><br/>
Что касается названия, <b>Sphinx</b> является аббревиатурой, которая официально расшифровывается как <b>SQL Phrase Index</b>.
<br/>
<i>И да, я знаю о проекте CMU Sphinx.</i>
<br/><br/>


<h2>1.2. Функциональность Sphinx</h2>
Основные возможности Sphinx:<br/>
<ul>
	<li>высокая производительность индексации и поиска;</li>
	<li>расширенные инструменты индексации и запросов (гибкий и многофункциональный текстовый токенизатор, язык запросов, несколько различных режимов ранжирования и т. д.);</li>
    <li>расширенная пост-обработка набора результатов (SELECT с условиями, WHERE, ORDER BY, GROUP BY, HAVING и т. д. поверх результатов текстового поиска);</li>
    <li>гарантированная масштабируемость до миллиардов документов, терабайт данных и тысяч запросов в секунду;</li>
    <li>простая интеграция с источниками данных SQL и XML, а также с интерфейсами поиска SphinxQL, SphinxAPI или SphinxSE;</li>
    <li>простое масштабирование с помощью распределенного поиска;</li>
</ul>
<br/><br/>
Если более подробно, Sphinx:<br/>
<ul>
    <li>имеет высокую скорость индексации (до 10-15 МБ / с на ядро на внутреннем тесте);</li>
    <li>имеет высокую скорость поиска (до 150-250 запросов / сек на ядро против 1 000 000 документов, 1,2 ГБ данных по внутреннему бенчмарку);</li>
    <li>имеет высокую масштабируемость (самый крупный из известных кластерных индексов составляет более 3 000 000 000 документов, а самый загруженный - более 50 000 000 запросов в день);</li>
    <li>обеспечивает хорошее ранжирование по релевантности за счет комбинации ранжирования по близости фразы и статистического ранжирования (BM25);</li>
    <li>предоставляет возможности распределенного поиска;</li>
    <li>обеспечивает формирование отрывков (сниппетов) документов;</li>
    <li>обеспечивает поиск изнутри приложения с интерфейсами SphinxQL или SphinxAPI, и изнутри MySQL с подключаемым механизмом хранения SphinxSE;</li>
    <li>поддерживает логические, фразовые, близкие по словам и другие типы запросов;</li>
    <li>поддерживает несколько полнотекстовых полей в документе (по умолчанию до 32);</li>
    <li>поддерживает несколько дополнительных атрибутов для каждого документа (например, группы, отметки времени и т. д.);</li>
    <li>поддерживает стоп-слова;</li>
    <li>поддерживает словари морфологических словоформ;</li>
    <li>поддерживает токенизацию исключений;</li>
    <li>поддерживает кодировку UTF-8;</li>
    <li>поддерживает стемминг (стеммеры для английского, русского, чешского и арабского языков встроены;
	стеммеры для французского, испанского, португальского, итальянского, румынского, немецкого, голландского, шведского, норвежского, датского, финского, венгерского языков
	доступны при сборке сторонней библиотекой libstemmer);</li>
    <li>поддерживает MySQL &laquo;из коробки&raquo; (поддерживаются все типы таблиц, включая MyISAM, InnoDB, NDB, Archive и т. д.);</li>
    <li>поддерживает PostgreSQL &laquo;из коробки&raquo;;</li>
    <li>поддерживает ODBC-совместимые базы данных (MS SQL, Oracle и т. д.) &laquo;из коробки&raquo;;</li>
    <li>...имеет более 50 других функций, не перечисленных здесь, см. руководство по настройке!</li>
</ul>
<br/><br/>

<h2>1.3. Где скачать Sphinx</h2>
Sphinx доступен на официальном веб-сайте <a href="http://sphinxsearch.com">sphinxsearch.com</a><br/>
Для версии 2.х tar-архив с дистрибутивом Sphinx включает следующее программное обеспечение:<br/>
<ul>
    <li><b>indexer</b>: утилита для создания полнотекстовых индексов;</li>
    <li><b>searchd</b>: демон, который позволяет внешнему ПО (например, веб-приложениям) выполнять поиск по полнотекстовым индексам;</li>
    <li><b>sphinxapi</b>: набор клиентских API-библиотек searchd для популярных языков веб-сценариев (PHP, Python, Perl, Ruby).</li>
    <li><b>spelldump</b>: простой инструмент командной строки для извлечения элементов из словаря формата <i>ispell</i> или <i>MySpell</i> (распространяется с OpenOffice), помогающий настроить индекс для использования со словоформами.</li>
    <li><b>indextool</b>: утилита для сброса прочей отладочной информации об индексе, добавленная в версии 0.9.9-rc2.</li>
    <li><b>wordbreaker</b>: утилита для разбивки сложных слов на отдельные слова, добавленная в версии 2.1.1.</li>
</ul>
<br/><br/>

<h2>1.4. Лицензирование</h2>
Эта программа - бесплатное ПО. Вы можете распространять и/или изменять его в соответствии с условиями GNU GPL, опубликованной Free Software Foundation.<br/>
Либо согласно 2-й версии данной Лицензии, либо (по вашему выбору) любой более поздней версии. Подробнее см. &laquo;копирование файла&raquo;.
Эта программа распространяется в надежде, что она будет полезна, но БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ. Даже без подразумеваемых гарантий ТОВАРНОЙ ПРИГОДНОСТИ или ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ.
Подробнее см. GNU GPL. Вы должны были получить копию GNU GPL вместе с этой программой.
Если нет, напишите в Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
Также может быть организовано лицензирование без GPL (для встроенного использования OEM/ISV), пожалуйста, свяжитесь с нами, чтобы обсудить возможности коммерческого лицензирования.
<br/><br/>

<h2>1.5. Разработчики</h2>
<h3>Автор</h3>
Изначальный автор Сфинкса (и до сих пор великодушный диктатор):<br/>
Andrew Aksyonoff (<a href="http://shodan.ru">shodan.ru</a>)
<br/><br/>

<h3>Команда</h3>
Прошлые и нынешние сотрудники Sphinx Technologies Inc, которых следует отметить в их работе над Sphinx (в алфавитном порядке):<br/>
Adam Rice, Adrian Nuta, Alexander Klimenko<br/>
Alexey Dvoichenkov, Alexey Vinogradov, Anton Tsitlionok<br/>
Eugene Kosov, Gloria Vinogradova, Ilya Kuznetsov<br/>
Kirill Shmatov, Rich Kelm, Stanislav Klinov<br/>
Steven Barker, Vladimir Fedorkov, Yuri Schapov<br/>
<br/><br/>

<h3>Внесшие свой вклад</h3>
Люди, которые внесли свой вклад в Sphinx, и их вклад (в произвольном порядке):<br/>
Robert "coredev" Bengtsson (Sweden) - исходная версия источника данных PostgreSQL<br/>
Len Kranendonk, Perl API<br/>
Dmytro Shteflyuk, Ruby API<br/>
<br/><br/>
Многие другие люди внесли свои идеи, отчеты об ошибках, исправления и т.д. Спасибо!
<br/><br/>

<h2>1.6. История</h2>
Разработка Sphinx началась еще в 2001 году, потому что мне не удалось найти приемлемое решение для поиска (для веб-сайта, управляемого базой данных),
которое отвечало бы моим требованиям. Фактически, каждый упомянутый далее аспект был важным и не имел качественной реализации:<br/>
<ul>
    <li>качество поиска (т.е. хорошая релевантность)</li>
    <li>методы статистического ранжирования работали довольно плохо, особенно на больших коллекциях небольших документов (форумы, блоги и т. д.)</li>
    <li>скорость поиска (особенно при поиске фраз, содержащих запрещенные слова, например, "быть или не быть")</li>
    <li>требования к диску и процессору при индексировании (важно в среде виртуального хостинга, не говоря уже о скорости индексации)</li>
</ul>
<br/><br/>
Несмотря на прошедшее время и многочисленные улучшения, внесенные в другие решения, до сих пор нет ПО, на которое я лично хотел бы перейти.
<br/><br/>
Учитывая это и множество положительных отзывов, полученных от пользователей Sphinx в последние годы, очевидным решением является продолжение разработки Sphinx (и, в конечном итоге, захват мира).
<br/><br/>

<h2>Часть 2. Установка</h2>
<h2>2.1. Поддерживаемые системы</h2>
Sphinx может быть скомпилирован из исходных кодов или установлен с использованием предварительно собранных пакетов.
Большинство современных систем UNIX с компилятором C ++ должны иметь возможность компилировать и запускать Sphinx без каких-либо модификаций.
<br/><br/>
Известные в настоящее время системы, на которых успешно работает Sphinx:<br/>
<ul>
    <li>Linux 2.4.x, 2.6.x, 3.x (many various distributions)</li>
    <li>Windows 2000, XP, 7, 8</li>
    <li>FreeBSD 4.x, 5.x, 6.x, 7.x, 8.x</li>
    <li>NetBSD 1.6, 3.0</li>
    <li>Solaris 9, 11</li>
    <li>Mac OS X</li>
</ul>
<br/><br/>
Известные поддерживаемые архитектуры CPU включают i386 (он же x86), amd64 (он же x86_64), SPARC64 и ARM.
<br/><br/>
Скорее всего, Sphinx также должен работать на других Unix-совместимых платформах и/или архитектурах.
Пожалуйста, сообщите о любых других окружениях, на которых вам удалось запустить Sphinx!
<br/><br/>
Версии на всех системах работают одинаково. Принципиальных функциональных ограничений на любой платформе нет.
<br/><br/>


<h2>2.2. Компиляция из исходников</h2>
<h3>2.2.1. Необходимые инструменты</h3>
В UNIX вам потребуются следующие инструменты для сборки и установки Sphinx:<br/>
- Работающий C++ компилятор. GNU gcc и clang подойдут.<br/>
- Программа make. GNU make гарантированно работает.
<br/><br/>
В Windows вам понадобится Microsoft Visual C/C ++ Studio .NET 2005 или выше.
Другие компиляторы/среды, вероятно, также будут работать, но на данный момент вам придется создавать make-файл (или другие файлы проекта, специфичные для среды) вручную.
<br/><br/>

<h3>2.2.2. Компиляция в Linux</h3>
Извлеките все из tarball дистрибутива (Вы до сих пор этого не сделали?). И перейдите в подкаталог sphinx.
(Мы используем версию 2.3.2-beta только в качестве примера; обязательно измените ее на конкретную версию, которую вы используете.)
<br/>
<code>
	$ tar xzvf sphinx-2.3.2-beta.tar.gz<br/>
    $ cd sphinx
</code>
<br/><br/>
Запустите программу настройки:<br/>
<code>$ ./configure</code>
<br/><br/>
Есть ряд параметров для настройки. Полный список можно получить, используя переключатель --help. Наиболее важные из них:<br/>
<i>--prefix</i> - указывает, где установить Sphinx; например <i>--prefix=/usr/local/sphinx</i> (во всех примерах используется этот префикс)<br/>
<i>--with-mysql</i> - указывает, где искать файлы MySQL include и файлы библиотеки в случае сбоя автоопределения<br/>
<i>--with-static-mysql</i> - собирает Sphinx со статически связанной поддержкой MySQL<br/>
<i>--with-pgsql</i> - указывает, где искать файлы include и библиотеки PostgreSQL<br/>
<i>--with-static-pgsql</i> - собирает Sphinx со статически связанной поддержкой PostgreSQL<br/>
<br/><br/>
Сборка бинарников:<br/>
<code>$ make</code>
<br/><br/>
Установите двоичные файлы в каталог по вашему выбору.<br/>
<small>(по умолчанию <i>/usr/local/bin/</i> в системах *nix, но переопределяется с помощью configure --prefix)</small><br/>
<code>$ make install</code>
<br/><br/>


<h3>2.2.3. Известные проблемы компиляции</h3>
Если configure не может найти заголовки и/или библиотеки MySQL, попробуйте проверить и установить пакет mysql-devel. В некоторых системах он не установлен по умолчанию.
<br/><br/>
Если make выдаёт ошибку, похожую на следующую:<br/>
<code>
	/bin/sh: g++: command not found<br/>
	make[1]: *** [libsphinx_a-sphinx.o] Error 127
</code>
<br/><br/>
Попробуйте проверить и установить пакет gcc-c++.
<br/><br/><br/>
Если же вы получаете ошибки этапа компиляции, которые выглядят примерно так:<br/>
<code>
	sphinx.cpp:67: error: invalid application of `sizeof' to<br/>
    incomplete type `Private::SizeError&lt;false&gt;`
</code>
<br/><br/>
Это скорее всего значит, что какая-то из проверок размеров типа во время компиляции не удалась. Наиболее вероятная причина в том, что тип <i>off_t</i> в вашей системе меньше 64-битного.
В качестве быстрого решения вы можете отредактировать <i>sphinx.h</i> и заменить <i>off_t</i> на <i>DWORD</i> в <i>typedef</i> для <i>SphOffset_t</i>,
но обратите внимание, что это запретит вам использовать полнотекстовые индексы размером более 2 ГБ.
Даже если данное решение вам поможет, сообщите о таких проблемах, указав точное сообщение об ошибке и сведения о компиляторе/ОС, чтобы мы могли правильно исправить их в следующих выпусках.
<br/><br/>
Если вы продолжаете получать какие-либо другие ошибки или приведенные выше предложения не помогли вам, не стесняйтесь обращаться к ней.
<br/><br/>


<h2>2.3. Установка пакетов Sphinx на Debian и Ubuntu</h2>
Есть два способа получить Sphinx для Ubuntu: обычные пакеты deb и репозиторий Launchpad PPA.
<br/><br/>
<b>Deb packages</b>. Sphinx требует установки нескольких библиотек в Debian/Ubuntu. Используйте apt-get для загрузки и установки этих зависимостей:
<br/><br/>
<code>
	$ sudo apt-get install mysql-client unixodbc libpq5
	<br /><br />
	<i>// Теперь вы можете установить Sphinx:</i><br />
	$ sudo dpkg -i sphinxsearch_2.3.2-beta-1~trusty_amd64.deb
</code>
<br/><br/>
<b>PPA repository</b> (только Ubuntu). Установить Sphinx из репозитория Sphinxsearch PPA намного проще, потому что вы получите все зависимости,
а также сможете обновить Sphinx до последней версии с помощью той же команды.
<br/><br/>
<code>
    <i>// Сначала добавьте репозиторий Sphinxsearch и обновите список пакетов:</i><br />
    $ sudo add-apt-repository ppa:builds/sphinxsearch-rel23<br />
    $ sudo apt-get update<br /><br /><br />
    <i>// Установить и/или обновить пакет sphinxsearch:</i><br />
    $ sudo apt-get install sphinxsearch
</code>
<br/><br/>
Демон Sphinx searchd можно запустить/остановить с помощью служебной команды:<br/>
<code>$ sudo service sphinxsearch start</code>
<br/><br/>

<h2>2.4. Установка пакетов Sphinx на RedHat и CentOS</h2>
В настоящее время мы распространяем Sphinx RPMS и SRPMS на нашем веб-сайте для версий 5.x и 6.x Red Hat Enterprise Linux, но они также могут быть установлены на CentOS.
<br/><br/>
Перед установкой убедитесь, что у вас установлены следующие пакеты:<br/>
<code>$ yum install postgresql-libs unixODBC</code>
<br/><br/>
Загрузите RedHat RPM с сайта Sphinx и установите его:<br/>
<code>$ rpm -Uhv sphinx-2.2.1-1.rhel6.x86_64.rpm</code>
<br/><br/>
После подготовки файла конфигурации (см. главу 2.7 Краткий обзор возможностей) вы можете запустить демон searchd:<br/>
<code>$ service searchd start</code>
<br/><br/>


<h2>2.5. Установка Sphinx в Windows</h2>
Установить Sphinx на сервер Windows часто проще, чем в среде Linux;
Если вы не собираетесь вносить исправления в код Sphinx, вы можете использовать предварительно скомпилированные двоичные файлы со страницы Загрузки на веб-сайте.<br/>
<ul>
    <li>Извлеките все из загруженного архива - <i>sphinx-2.3.2-beta-win32.zip</i> или <i>sphinx-2.3.2-beta-win32-pgsql.zip</i>, если вам также нужна поддержка PostgresSQL.
	(Мы используем версию 2.3.2-beta здесь только для примера; обязательно измените ее на конкретную версию, которую вы используете.)
	Вы можете использовать Windows Explorer в Windows XP и более поздних версиях для извлечения файлов, или бесплатный пакет, например 7Zip, чтобы открыть архив.</li>

    <li>В оставшейся части этого руководства мы будем предполагать, что папки распакованы в <i>C:\Sphinx</i>, так что <i>searchd.exe</i> можно найти в <i>C:\Sphinx\bin\searchd.exe</i>.
	Если вы решите использовать другое место для папок или файла конфигурации, измените его соответствующим образом.</li>

    <li>Отредактируйте содержимое <i>sphinx.conf.in</i>, особенно записи, относящиеся к <i>@CONFDIR@</i>, на пути, подходящие для вашей системы.</li>

    <li>Установите searchd как службу Windows:<br/>
    <code>C:\Sphinx\bin> C:\Sphinx\bin\searchd --install --config C:\Sphinx\sphinx.conf.in --servicename SphinxSearch</code>
	</li>

    <li>Служба searchd теперь будет указана на панели &laquo;Службы&raquo; в консоли управления, доступной в разделе &laquo;Инструменты администрирования&raquo;.
	Она не будет запущена, так как вам нужно будет настроить его и построить индексы с помощью индексатора перед запуском службы. Руководство для этого можно найти в главе 2.7 &laquo;Краткий обзор&raquo;.</li>

    <li>На следующих этапах установки (которые включают запуск индексатора практически также, как и в Linux) вы можете обнаружить ошибку, связанную с тем, что libmysql.dll не найден.
	Если у вас установлен MySQL, вы должны найти копию этой библиотеки в каталоге <i>Windows</i>, а иногда и в <i>Windows\System32</i>, а в случае сбоя - в основных каталогах MySQL.
	Если вы все же получили сообщение об ошибке, скопируйте libmysql.dll в каталог bin.</li>
</ul>
<br/><br/>


<h2>2.6. Устаревшие функции Sphinx и изменения в конфигурации по умолчанию</h2>
<h3>Изменения в v.2.2.1-beta</h3>
В версии 2.2.1-beta мы решили удалить некоторые старые функции. Все они некоторое время были &laquo;неофициально&raquo; устаревшими. И мы сообщаем вам об этом сейчас.
<br/><br/>
Список изменений:<br/>
<ul>
	<li>32-битные идентификаторы документов устарели. Наши бинарные выпуски теперь по умолчанию построены с 64-битными идентификаторами.
		Обратите внимание, что они по-прежнему могут загружать более старые индексы с 32-битными идентификаторами, но эта поддержка в конечном итоге будет удалена.
		Фактически, это было объявлено устаревшим некоторое время назад, но теперь мы просто хотим прояснить это: мы не видим никакого смысла в попытках сохранить ОЗУ вашего сервера таким образом.</li>
    <li><i>dict=crc</i> теперь устарел. Он имеет ряд ограничений, наиболее важными из которых являются конфликты ключевых слов и отсутствие (хорошей) поддержки сопоставления подстановочных знаков.
		Вы можете узнать больше об этих ограничениях в нашей документации.</li>
    <li><i>charset_type=sbcs</i> устарел, мы постепенно переходим на использование только UTF. Даже если ваша база данных SBCS (вероятно, по историческим причинам, да?).
		Это должно быть абсолютно тривиальным решением, просто добавьте предварительный запрос для получения данных в UTF-8, и все готово.
		Кроме того, на самом деле наш текущий токенизатор UTF-8 даже быстрее, чем токенизатор SBCS.</li>
    <li>custom sort (<i>@custom</i>) теперь удален из Sphinx. Эта функция была введена задолго до того, как сортировка по выражению стала реальностью, и уже очень давно устарела.
    <li><i>enable_star</i> устарело. Ранее по умолчанию <i>enable_star= 0</i>, что было связано с совместимостью с очень старой версией Sphinx. Такой неявный поиск не очень интуитивен.
		Итак, мы решили в конечном итоге удалить его и совсем недавно пометили как устаревший. Мы планируем полностью удалить этот конфигурационный ключ в ветке 2.2.X.</li>
    <li>атрибуты <i>str2ordinal</i> устарели. Эта функция позволяет выполнять сортировку по строке. Но это также можно сделать с помощью обычных строковых атрибутов, которые намного проще использовать.
		<i>str2ordinal</i> охватывает лишь небольшую часть этой функциональности и больше не требуется.</li>
    <li>атрибуты <i>str2wordcount</i>  устарели. <i>index_field_lengths=1</i> создаст целочисленный атрибут с автоматически устанавливаемой длиной поля, и мы рекомендуем использовать этот ключ конфигурации, когда вам нужно сохранить длину полей.
		Кроме того, <i>index_field_lengths=1</i> позволяет использовать новые формулы ранжирования, такие как BM25F().</li>
    <li><i>hit_format</i> устарело. Это скрытый конфигурационный ключ - он не упоминается в нашей документации. Но это есть, и возможно, что кто-то может им воспользоваться.
		А теперь мы вас призываем: не используйте его. Значение по умолчанию - inline, и это новый стандарт. 'plain' hit_format устарел и будет удален в ближайшем будущем.</li>
    <li><i>docinfo=inline</i> устарело. Теперь вы можете использовать <i>ondisk_attrs</i> или <i>ondisk_attrs_default</i> вместо этого.</li>
    <li><i>workers=threads</i> теперь по умолчанию для всех ОС. В будущем мы избавимся от других режимов.</li>
    <li><i>mem_limit=128M</i> теперь по умолчанию.</li>
    <li><i>rt_mem_limit=128M</i> теперь по умолчанию.</li>
    <li><i>ondisk_dict</i> и <i>ondisk_dict_default</i> устарели.Таким образом не нужно экономить оперативную память.</li>
    <li><i>compat_sphinxql_magics</i> удалено. Теперь вы не можете использовать старый формат результатов, и SphinxQL всегда больше похож на ANSI SQL.</li>
    <li>Полностью удалён <i>xmlpipe</i>. Это было очень старое специальное решение для конкретного клиента. <i>xmlpipe2</i> превосходит его во всех аспектах.</li>
	<li>Вызов <i>SetWeights()</i> давно устарел и теперь удален из официальных API.</li>
</ul>
<br/><br/>
Режим сопоставления по умолчанию для API теперь &laquo;расширен&raquo;. Фактически, все остальные режимы устарели. Вместо этого мы рекомендуем использовать расширенный синтаксис запроса.
<br/><br/>
Ни один из различных методов запросов не является устаревшим, но начиная с версии 2.2.1-beta, SphinxQL является наиболее продвинутым методом.
Мы планируем когда-нибудь удалить SphinxAPI и Sphinx SE, поэтому на вашем месте было бы неплохо начать использовать SphinxQL.
<br/><br/>

<h3>Изменения в v.2.2.2-beta</h3>
- Удалены устаревшие директивы "address" и "port". Вместо этого используйте "listen".<br/>
- Удалены атрибуты <i>str2wordcount</i>. Вместо них используйте <i>index_field_lengths=1</i>.<br/>
- Удалены атрибуты <i>str2ordinal</i>. Для сортировки используйте строковые атрибуты.<br/>
- Удалены <i>ondisk_dict</i> и <i>ondisk_dict_default</i>.<br/>
- Удалены <i>charset_type</i> и <i>mssql_unicode</i> - теперь мы поддерживаем только кодировку UTF-8.<br/>
- Удален устаревший <i>enable_star</i>. Теперь всегда работайте как с <i>enable_star=1</i>.<br/>
- Удален поиск CLI, который сбивал людей с толку, а не помогал им, а также <i>sql_query_info</i>.<br/>
- Теперь по умолчанию <i>thread_stack=1M</i>.<br/>
- Вызов <i>SetOverride()</i> устарел.<br/>
- Вызов <i>SetMatchMode()</i> устарел.<br/>
<br/><br/>


<h3>Изменения в v.2.2.3-beta</h3>
- Удален ненужный ключ max_matches из файла конфигурации.
<br/><br/>

<h2>2.7. Краткий обзор возможностей Sphinx</h2>
Все приведенные ниже примеры команд предполагают, что вы установили Sphinx в <i>/usr/local/sphinx</i>, поэтому searchd можно найти в <i>/usr/local/sphinx/bin/searchd</i>.
<br/><br/>
Чтобы использовать Sphinx, вам необходимо для начала создать файл конфигурации.
<br/><br/>
<ul>
    <li>Стандартное имя файла конфигурации изначально: <i>sphinx.conf</i>. По умолчанию все программы Sphinx ищут этот файл в текущем рабочем каталоге.</li>
    <li>Пример файла конфигурации называется <i>sphinx.conf.dist</i>, он создаётся программой configure и там задокументированы все параметры.</li>
    <li>Скопируйте и правьте этот файл для настройки собственной конфигурации.</li>
</ul>
<br/><br/>

<code>
    <i>// (подразумевается, что Sphinx установлен в /usr/local/sphinx/)</i><br />
    $ cd /usr/local/sphinx/etc<br />
    $ cp sphinx.conf.dist sphinx.conf<br />
    $ vi sphinx.conf
</code>
<br/><br/>
Файл конфигурации <i>sphinx.conf.dist</i> в качестве примера настроен для индексации таблицы документов из теста базы данных MySQL.
Используем файл данных <i>example.sql</i>, чтобы заполнить эту таблицу несколькими документами для целей тестирования:
<br/><br/>
<code>
    $ mysql -u test &lt; /usr/local/sphinx/etc/example.sql
</code>
<br/><br/>
Запустите indexer, чтобы создать полнотекстовый индекс из ваших данных:<br/>
<code>
    $ cd /usr/local/sphinx/etc<br />
    $ /usr/local/sphinx/bin/indexer --all
</code>
<br/><br/>
Теперь запросите свои индексы!<br/>
<code>
    <i>// Connect to server:</i><br />
    $ mysql -h0 -P9306<br /><br />

    SELECT * FROM test1 WHERE MATCH('my document');<br />
    INSERT INTO rt VALUES (1, 'this is', 'a sample text', 11);<br />
    INSERT INTO rt VALUES (2, 'some more', 'text here', 22);<br />
    SELECT gid/11 FROM rt WHERE MATCH('text') GROUP BY gid;<br />
    SELECT * FROM rt ORDER BY gid DESC;<br />
    SHOW TABLES;<br />
    SELECT *, WEIGHT() FROM test1 WHERE MATCH('"document one"/1');SHOW META;<br />
    SET profiling=1;SELECT * FROM test1 WHERE id IN (1,2,4);SHOW PROFILE;<br />
    SELECT id, id%3 idd FROM test1 WHERE MATCH('this is | nothing') GROUP BY idd;SHOW PROFILE;<br />
    SELECT id FROM test1 WHERE MATCH('is this a good plan?');SHOW PLAN;<br />
    SELECT COUNT(*) c, id%3 idd FROM test1 GROUP BY idd HAVING COUNT(*)>1;<br />
    SELECT COUNT(*) FROM test1;<br />
    CALL KEYWORDS ('one two three', 'test1');<br />
    CALL KEYWORDS ('one two three', 'test1', 1);
</code>
Удачного поиска!
<br/><br/>


<h2>3.1 Источники данных (Data sources)</h2>
Данные, подлежащие индексированию, могут быть получены из разных источников: базы данных SQL, текстовые файлы, файлы HTML, почтовые ящики и т.Д.
С точки зрения Sphinx, данные, которые он индексирует, представляют собой набор структурированных документов, каждый из которых имеет одинаковый набор полей и атрибутов.
Это похоже на SQL, где каждая строка будет соответствовать документу, а каждый столбец либо полю, либо атрибуту.
<br /><br />
В зависимости от того, из какого источника Sphinx должен получать данные, требуется разны код для извлечения данных и подготовки к индексированию.
Этот код называется data source driver (или просто driver или data source для краткости).
<br /><br />
На момент написания этой статьи существуют встроенные драйверы для MySQL, PostgreSQL, MS SQL (в Windows) и ODBC.
Существует также общий драйвер, называемый xmlpipe2, который запускает указанную команду и считывает данные со своего stdout. Описание формата дано в Разделе 3.9, раздел &laquo;xmlpipe2 data source&raquo;.
<br /><br />
В 2.2.1-бета добавлен источник данных tsvpipe (Tab Separated Values) и csvpipe (Comma Separated Values).
Вы можете получить дополнительную информацию по ним в Разделе 3.10, &laquo;источник данных tsvpipe \ csvpipe (вкладка \ Comma Separated Values)&raquo;.
<br /><br />
При необходимости может использоваться несколько источников на индекс.
Они будут последовательно обрабатываться в том же порядке, в котором были указан в определении индекса.
Все документы, поступающие из этих источников, будут объединены, как если бы они поступали из одного источника.
<br /><br />

<h2>3.2 Полнотекстовые поля (Full-text fields)</h2>
Полные текстовые поля (или просто поля для краткости) - это текстовое содержимое документа, которое индексируется Sphinx и по которому может осуществляться быстрый поиск.
<br /><br />
Поля именуются, и вы можете ограничить поиск одним полем (например, поиск только по &laquo;title&raquo;) или подмножеством полей (например, только для &laquo;title&raquo; и &laquo;abstract&raquo;).
Формат индекса Sphinx обычно поддерживает до 256 полей. Однако до версии 2.0.1-бета-индексы были принудительно ограничены 32 полями из-за определенных осложнений в соответствующем движке.
В версии 2.0.2-бета была добавлена полная поддержка 256 полей.
<br /><br />
Обратите внимание, что исходное содержимое полей не сохраняется в индексе Sphinx.
Текст, который вы отправляете в Sphinx, обрабатывается, и из этого текста создается полнотекстовый индекс (специальная структура данных, которая обеспечивает быстрый поиск ключевого слова).
Но исходное содержимое текста затем просто отбрасывается. Sphinx предполагает, что вы все равно храните это содержимое в другом месте.
<br /><br />
Более того, невозможно полностью восстановить исходный текст, так как при индексировании будут потеряны конкретные пробелы, регистр, пунктуация и т.д.
Теоретически можно частично восстановить документ из полнотекстового индекса Sphinx, но это будет весьма медленно (особенно если используется словарь CRC, который даже не сохраняет исходные ключевые слова и работает с их хэшами).
<br /><br />

<h2>3.3 Атрибуты</h2>
Атрибуты - это дополнительные значения, связанные с каждым документом, которые могут использоваться для выполнения дополнительной фильтрации и сортировки во время поиска.
<br /><br />
Часто требуется дополнительно обрабатывать результаты полнотекстового поиска, основанные не только на сопоставлении ID документа и его релевантности,
но и на ряде других значений для каждого документа. Например, может потребоваться сначала сортировать результаты поиска новостей по дате, а потом по релевантности.
Или, например, поиск продуктов в пределах определенного диапазона цен и т.п.
Чтобы выполнять поиск эффективно, Sphinx позволяет прикрепить к каждому документу ряд дополнительных атрибутов и сохранить их значения в полнотекстовом индексе.
Затем можно использовать сохраненные значения для фильтрации, сортировки или группировки полнотекстовых совпадений.
<br /><br />
Атрибуты, в отличие от полей, не индексируются по полному тексту. Они хранятся в индексе, но их невозможно найти в виде полнотекстового текста, и попытка сделать это приводит к ошибке.
<br /><br />
Например, невозможно использовать расширенное выражение режима соответствия (mode expression) @column 1 для соответствия документам, где column равен 1,
если столбец является атрибутом (даже если числовые значения индексируются).
<br /><br />
Атрибуты могут использоваться для фильтрации, для ограничения возвращаемых строк, а также для сортировки или группировки результатов; вполне возможно сортировать результаты,
основанные исключительно на атрибутах, и игнорировать инструменты релевантности поиска. Кроме того, демон поиска возвращает атрибуты, а индексированный текст - нет.
<br /><br />
Хорошим примером атрибутов будет таблица сообщений на форуме. Предположим, что только поля заголовка и содержимого должны быть доступны для полнотекстового поиска,
но иногда также требуется ограничить поиск определенным автором или подфорумом (т.е. Искать только те строки, которые имеют определенные значения столбцов author_id или forum_id в таблице SQL);
или группировать совпадающие записи по месяцам post_date и подсчитывать количество совпадений в каждой группе.
<br /><br />
Этого можно достичь, указав все упомянутые столбцы (исключая заголовок и контент, которые являются полнотекстовыми полями), как атрибуты, индексируя их, а затем используя вызовы API для настройки фильтрации, сортировки и группировки. Пример ниже:
<br /><br />
<b>Пример куска sphinx.conf:</b><br />
<code>
	...<br />
	sql_query = SELECT  id, title, content, \<br />
	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; author_id, forum_id, post_date FROM my_forum_posts<br />
	sql_attr_uint = author_id<br />
	sql_attr_uint = forum_id<br />
	sql_attr_timestamp = post_date<br />
	...<br />
</code>

<br /><br />

<b>Пример кода приложения (на PHP):</b><br />
<code>
	<i>// Искать только сообщения автора, чей ID = 123</i><br />
	$cl->SetFilter ( "author_id", array ( 123 ) );
	<br /><br />
	<i>// искать сообщения только в подфорумах 1, 3 и 7</i><br />
	$cl->SetFilter ( "forum_id", array ( 1,3,7 ) );
	<br /><br />
	<i>// отсортировать найденные сообщения по дате публикации в порядке убывания</i><br />
	$cl->SetSortMode ( SPH_SORT_ATTR_DESC, "post_date" );<br />
</code>
<br /><br />
Атрибуты именуются. Имена атрибутов нечувствительны к регистру. Атрибуты не индексируются полностью; они сохраняются в индексе как есть.
<br /><br />
В настоящее время поддерживаются следующие типы атрибутов:
<ul>
	<li>целые числа без знака (от 1 до 32 бит);</li>
	<li>Временные метки UNIX;</li>
	<li>значения с плавающей запятой (32-битная, одноточечная IEEE 754);</li>
	<li>строки (с 1.10-бета);</li>
	<li>JSON (начиная с версии 2.1.1-бета);</li>
	<li>MVA, многозначные атрибуты (списки переменной длины 32-разрядных целых чисел без знака).</li>
</ul>
<br /><br />
Полный набор значений атрибутов для каждого документа иногда называют docinfo. Docinfos можно хранить отдельно от основных полнотекстовых индексных данных (&laquo;extern&raquo; storage, в файле .spa) или прикрепляться к каждому вхождению идентификатора документа в полнотекстовые данные индекса (&laquo;inline&raquo; storage в файле .spd ).
<br /><br />
При использовании внешнего хранилища копия файла .spa (со всеми значениями атрибутов для всех документов) постоянно сохраняется в ОЗУ по поисковому запросу. Это сделано для производительности, так как случайный доступ к диску работает слишком медленно.
<br /><br />
Напротив, встроенное хранилище вообще не требует какой-либо дополнительной ОЗУ, однако это связано с значительным раздуванием размера индекса: помните, что он копирует все значения атрибута каждый раз, когда упоминается идентификатор документа, и это будет происходить для каждого отличного ключевого слова в документе.
<br /><br />
Inline может быть единственным жизнеспособным вариантом, если у вас есть только несколько атрибутов и вам нужно работать с большими наборами данных в ограниченной ОЗУ. Однако в большинстве случаев внешнее хранилище делает индексирование и поиск намного более эффективным.
<br /><br />

Требования к памяти времени поиска для внешнего хранилища: <br />
<code>(1 + number_of_attrs) * number_of_docs * 4 байта </code>
<br />
т.е. для примера, 10 миллионов документов с 2 группами и 1 временной отметкой займут:<br />
<code>(1 + 2 + 1) * 10M * 4 = 160 МБ ОЗУ</code>
<br /><br />
Этот рассчёт приведён для одного демона, а не запроса. То есть searchd выделит 160 МБ при запуске, прочитает данные и сохранит их совместно с запросами.
<br /><br />

<h2>3.4 MVA (многозначные атрибуты)</h2>
MVA, или многозначные атрибуты, являются важным специальным типом атрибутов для каждого документа в Sphinx.
MVA позволяют прикреплять наборы числовых значений к каждому документу. Это полезно для реализации тегов статей, категорий продуктов и т. Д.
Поддерживается фильтрация и группировка (но не сортировка) по атрибутам MVA.
<br /><br />
Начиная с версии 2.0.2-beta, значения MVA могут быть либо 32-разрядными целыми числами без знака (<i>UNSIGNED INTEGER</i>),
либо 64-разрядными целыми числами со знаком (<i>BIGINT</i>). До версии 2.0.1-beta поддерживались только 32-битные значения без знака.
<br /><br />
Установленный размер не ограничен, вы можете иметь произвольное количество значений, прикрепленных к каждому документу,
если это позволяет ОЗУ (файл <i>.spm</i>, содержащий значения MVA, будет предварительно кэширован в ОЗУ программой <i>searchd</i>).
Исходные данные могут быть взяты как из отдельного запроса, так и из поля документа (см. тип источника в <i>sql_attr_multi</i>).
В первом случае запрос должен будет вернуть пары значений идентификатора документа и MVA, во втором поле будет проанализировано на предмет целочисленных значений.
Абсолютно никаких требований к порядку входящих данных - значения будут автоматически сгруппированы по идентификатору документа (и внутренне отсортированы по одному идентификатору)
во время индексирования в любом случае.
<br /><br />
При фильтрации документ будет соответствовать фильтру по атрибуту MVA, если какое-либо из значений удовлетворяет условию фильтрации.
<i>(Следовательно, документы, прошедшие через фильтры исключения, не будут содержать запрещенных значений)</i>
При группировке по атрибуту MVA документ будет входить в столько групп, сколько существует различных значений MVA, связанных с этим документом.
Например, если коллекция содержит ровно 1 документ, имеющий &laquo;тег&raquo; MVA со значениями 5, 7 и 11, группировка по &laquo;тегу&raquo; приведет к созданию 3 групп
с &laquo;COUNT (*)&raquo;, равным 1, и &laquo;GROUPBY ()&raquo;. ключевые значения 5, 7 и 11 соответственно.
Также обратите внимание, что группировка по MVA может привести к дублированию документов в результирующем наборе: поскольку каждый документ может участвовать во многих группах,
его можно выбрать как лучший в более чем одной группе, что приведет к дублированию идентификаторов.
PHP API исторически использует упорядоченный хеш для идентификатора документа для результирующих строк; поэтому вам также необходимо использовать SetArrayResult (), чтобы использовать группировку по MVA с PHP API.
<br /><br />

<h2>3.5 Индексы</h2>
Чтобы быстро отвечать на запросы полнотекстового поиска, Sphinx необходимо создать специальную структуру данных, оптимизированную для таких запросов, из ваших текстовых данных. Эта структура называется индексом; и процесс построения индекса из текста называется индексированием.
<br /><br />
Для разных задач разумно выбирать подходящий тип индекса. Например, индекс диска на основе дерева будет легко обновляться (т.е. вставлять новые документы в существующий индекс), но медленнее искать. Архитектура Sphinx позволяет внутренне использовать различные типы индексов (также иногда называются backends), реализовать которые сравнительно легко.
<br /><br />
Начиная с 1.10-бета, Sphinx предоставляет 2 разных бэкенда:  disk index backend и RT (realtime) index backend.
<br /><br />
Индексы дисков предназначены для обеспечения максимальной скорости индексирования и поиска, используя при этом как можно меньше RAM. Это реализовано за счет обновления текстовых индексов. Вы не можете обновить существующий документ или поэтапно добавить новый документ в индекс диска. Вы можете только перезагрузить весь индекс диска с нуля.
<br /><br />
Обратите внимание - обновлять атрибуты документа &laquo;на лету&raquo; возможно даже с дисковыми индексами.
<br /><br />
Это ограничение "rebuild only" на первый взгляд может выглядеть как большая проблема. Однако его можно очень часто обойти довольно простым образом - настраивая несколько дисковых индексов, выполняя поиск по ним и восстанавливая только часть последних измененных данных. Подробные сведения см. В разделе 3.11 &laquo;Обновления индексов&raquo;.
<br /><br />
RT-индексы позволяют вам внедрять динамические обновления и инкрементные дополнения к полному текстовому индексу. RT означает &laquo;реальное время&raquo;, и это действительно &laquo;soft realtime&raquo; с точки зрения записи. Это значит, что большинство изменений индекса становятся доступными для поиска с точностью до 1 миллисекунды или менее, но иногда могут задерживаться на несколько секунд. (Поиск по-прежнему будет работать даже во время этих задержек) Подробнее см. Главу 4 &laquo;Индексы реального времени&raquo;.
<br /><br />
И последнее, но не менее важное: Sphinx поддерживает так называемые распределенные индексы (distributed indexes). По сравнению с дисковыми и RT-индексами они являются не реальным физическим бэкэндом, а скорее списками локальных или удаленных индексов, по которым можно искать прозрачно для приложения, при этом Sphinx выполняет все обязанности по отправке поисковых запросов на удаленные компьютеры в кластере, агрегирование наборов результатов, повторение неудачных запросов и даже выполнение некоторой балансировки нагрузки. См. Раздел 5.8 &laquo;Распределенный поиск&raquo; для обсуждения распределенных индексов.
<br /><br />
При необходимости может столько угодно индексов на файл конфигурации. Утилита indexer может переиндексировать либо все из них (если задана опция -all), либо определенное явно указанное подмножество. утилита searchd будет обслуживать все указанные индексы, а клиенты могут указывать, какие индексы искать во время выполнения.

<br /><br />
---
<br /><br />
Как видно тут пропущено прилично глав. Что ж... пока я перевёл лишь то, что мне было необходимо для работы.
<br /><br />
---
<br /><br />

<h2>3.11 Обновление индексов в реальном времени</h2>
Существует два основных подхода к поддержанию полнотекстового содержимого индекса.
<br /><br />
<b>Обратите внимание, что оба этих подхода касаются задачи полнотекстовых обновлений данных, а не обновлений атрибутов. Быстрые обновления атрибутов поддерживаются с версии 0.9.8. Подробнее см. В описании вызова API-адресов UpdateAttributes.</b>
<br /><br />
Во-первых, вы можете использовать disk-based индексы, разбивать их вручную и периодически перестраивать небольшие разделы (так называемые &laquo;дельта&raquo;). Минимизируя размер обновлений, вы можете уменьшить среднюю задержку индексации до уровня 30-60 секунд. Этот подход был единственным, доступным в версиях 0.9.x. В огромных базах это действительно может быть самым эффективным. Подробнее см. Раздел 3.12 &laquo;Обновления индекса Delta&raquo;.
<br /><br />
Во-вторых, версии 1.x (начиная с 1.10-бета) добавлена поддержка так называемых индексов реального времени (RT indexes), которые позволяют обновлять полнотекстовые данные &laquo;на лету&raquo;. Обновления RT индексов могут отразиться в результатах поиска через 1-2 миллисекунды (0.001-0.002 сек). Однако индекс RT менее эффективен для индексирования огромных объемов данных. Подробнее см. Главу 4, Индексы реального времени.

</body>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(54768061, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/54768061" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
</html>
