# Sphinx Russian Docs

<h2>3.1 Источники данных (Data sources)</h2>

Данные, подлежащие индексированию, могут быть получены из разных источников: базы данных SQL, текстовые файлы, файлы HTML, почтовые ящики и т.Д. С точки зрения Sphinx, данные, которые он индексирует, представляют собой набор структурированных документов, каждый из которых имеет одинаковый набор полей и атрибутов. Это похоже на SQL, где каждая строка будет соответствовать документу, а каждый столбец либо полю, либо атрибуту.
<br /><br />
В зависимости от того, из какого источника Sphinx должен получать данные, требуется разны код для извлечения данных и подготовки к индексированию. Этот код называется data source driver (или просто driver или data source для краткости).
<br /><br />
На момент написания этой статьи существуют встроенные драйверы для MySQL, PostgreSQL, MS SQL (в Windows) и ODBC. Существует также общий драйвер, называемый xmlpipe2, который запускает указанную команду и считывает данные со своего stdout. Описание формата дано в Разделе 3.9, раздел «xmlpipe2 data source».
<br /><br />
В 2.2.1-бета добавлен источник данных tsvpipe (Tab Separated Values) и csvpipe (Comma Separated Values). Вы можете получить дополнительную информацию по ним в Разделе 3.10, «источник данных tsvpipe \ csvpipe (вкладка \ Comma Separated Values)».
<br /><br />
При необходимости может использоваться несколько источников на индекс. Они будут последовательно обрабатываться в том же порядке, в котором были указан в определении индекса. Все документы, поступающие из этих источников, будут объединены, как если бы они поступали из одного источника.
<br /><br />

<h2>3.2 Полнотекстовые поля (Full-text fields)</h2>
Полные текстовые поля (или просто поля для краткости) - это текстовое содержимое документа, которое индексируется Sphinx и по которому может осуществляться быстрый поиск.
<br /><br />
Поля именуются, и вы можете ограничить поиск одним полем (например, поиск только по «title») или подмножеством полей (например, только для «title» и «abstract»). Формат индекса Sphinx обычно поддерживает до 256 полей. Однако до версии 2.0.1-бета-индексы были принудительно ограничены 32 полями из-за определенных осложнений в соответствующем движке. В версии 2.0.2-бета была добавлена полная поддержка 256 полей.
<br /><br />
Обратите внимание, что исходное содержимое полей не сохраняется в индексе Sphinx. Текст, который вы отправляете в Sphinx, обрабатывается, и из этого текста создается полнотекстовый индекс (специальная структура данных, которая обеспечивает быстрый поиск ключевого слова). Но исходное содержимое текста затем просто отбрасывается. Sphinx предполагает, что вы все равно храните это содержимое в другом месте.
<br /><br />
Более того, невозможно полностью восстановить исходный текст, так как при индексировании будут потеряны конкретные пробелы, регистр, пунктуация и т.д. Теоретически можно частично восстановить документ из полнотекстового индекса Sphinx, но это будет весьма медленно (особенно если используется словарь CRC, который даже не сохраняет исходные ключевые слова и работает с их хэшами).
<br /><br />

<h2>3.3 Атрибуты</h2>
Атрибуты - это дополнительные значения, связанные с каждым документом, которые могут использоваться для выполнения дополнительной фильтрации и сортировки во время поиска.
<br /><br />
Часто требуется дополнительно обрабатывать результаты полнотекстового поиска, основанные не только на сопоставлении ID документа и его релевантности, но и на ряде других значений для каждого документа. Например, может потребоваться сначала сортировать результаты поиска новостей по дате, а потом по релевантности. Или, например, поиск продуктов в пределах определенного диапазона цен и т.п. Чтобы выполнять поиск эффективно, Sphinx позволяет прикрепить к каждому документу ряд дополнительных атрибутов и сохранить их значения в полнотекстовом индексе. Затем можно использовать сохраненные значения для фильтрации, сортировки или группировки полнотекстовых совпадений.
<br /><br />
Атрибуты, в отличие от полей, не индексируются по полному тексту. Они хранятся в индексе, но их невозможно найти в виде полнотекстового текста, и попытка сделать это приводит к ошибке.
<br /><br />
Например, невозможно использовать расширенное выражение режима соответствия (mode expression) @column 1 для соответствия документам, где column равен 1, если столбец является атрибутом (даже если числовые значения индексируются).
<br /><br />
Атрибуты могут использоваться для фильтрации, для ограничения возвращаемых строк, а также для сортировки или группировки результатов; вполне возможно сортировать результаты, основанные исключительно на атрибутах, и игнорировать инструменты релевантности поиска. Кроме того, демон поиска возвращает атрибуты, а индексированный текст - нет.
<br /><br />
Хорошим примером атрибутов будет таблица сообщений на форуме. Предположим, что только поля заголовка и содержимого должны быть доступны для полнотекстового поиска, но иногда также требуется ограничить поиск определенным автором или подфорумом (т.е. Искать только те строки, которые имеют определенные значения столбцов author_id или forum_id в таблице SQL); или группировать совпадающие записи по месяцам post_date и подсчитывать количество совпадений в каждой группе.
<br /><br />
Этого можно достичь, указав все упомянутые столбцы (исключая заголовок и контент, которые являются полнотекстовыми полями), как атрибуты, индексируя их, а затем используя вызовы API для настройки фильтрации, сортировки и группировки. Пример ниже:
<br /><br />
<b>Example sphinx.conf part:</b><br />
<code>
...<br />
sql_query = SELECT  id, title, content, \<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; author_id, forum_id, post_date FROM my_forum_posts<br />
sql_attr_uint = author_id<br />
sql_attr_uint = forum_id<br />
sql_attr_timestamp = post_date<br />
...<br />
</code>

<br /><br />

<b>Example application code (in PHP):</b><br />
<code>
// only search posts by author whose ID is 123<br />
$cl->SetFilter ( "author_id", array ( 123 ) );
<br /><br />
// only search posts in sub-forums 1, 3 and 7<br />
$cl->SetFilter ( "forum_id", array ( 1,3,7 ) );
<br /><br />
// sort found posts by posting date in descending order<br />
$cl->SetSortMode ( SPH_SORT_ATTR_DESC, "post_date" );<br />
</code>
<br /><br />
Атрибуты именуются. Имена атрибутов нечувствительны к регистру. Атрибуты не индексируются полностью; они сохраняются в индексе как есть.
<br /><br />
В настоящее время поддерживаются следующие типы атрибутов:
<ul>
<li>  целые числа без знака (от 1 до 32 бит);</li>
<li>  Временные метки UNIX;</li>
<li>  значения с плавающей запятой (32-битная, одноточечная IEEE 754);</li>
<li>  строки (с 1.10-бета);</li>
<li>  JSON (начиная с версии 2.1.1-бета);</li>
<li>  MVA, многозначные атрибуты (списки переменной длины 32-разрядных целых чисел без знака).</li>
</ul>
<br /><br />
Полный набор значений атрибутов для каждого документа иногда называют docinfo. Docinfos можно хранить отдельно от основных полнотекстовых индексных данных («extern» storage, в файле .spa) или прикрепляться к каждому вхождению идентификатора документа в полнотекстовые данные индекса («inline» storage в файле .spd ).
<br /><br />
При использовании внешнего хранилища копия файла .spa (со всеми значениями атрибутов для всех документов) постоянно сохраняется в ОЗУ по поисковому запросу. Это сделано для производительности, так как случайный доступ к диску работает слишком медленно.
<br /><br />
Напротив, встроенное хранилище вообще не требует какой-либо дополнительной ОЗУ, однако это связано с значительным раздуванием размера индекса: помните, что он копирует все значения атрибута каждый раз, когда упоминается идентификатор документа, и это будет происходить для каждого отличного ключевого слова в документе.
<br /><br />
Inline может быть единственным жизнеспособным вариантом, если у вас есть только несколько атрибутов и вам нужно работать с большими наборами данных в ограниченной ОЗУ. Однако в большинстве случаев внешнее хранилище делает индексирование и поиск намного более эффективным.
<br /><br />

Требования к памяти времени поиска для внешнего хранилища: <br />
<code>  (1 + number_of_attrs) * number_of_docs * 4 байта </code><br />
т.е. для примера 10 миллионов документов с 2 группами и 1 временной отметкой займут:<br />
<code>  (1 + 2 + 1) * 10M * 4 = 160 МБ ОЗУ </code>
<br /><br />
Этот рассчёт приведён для одного демона, а не запроса. То есть searchd выделит 160 МБ при запуске, прочитает данные и сохранит их совместно с запросами.
<br /><br />



<h2>3.5 Индексы</h2>
Чтобы быстро отвечать на запросы полнотекстового поиска, Sphinx необходимо создать специальную структуру данных, оптимизированную для таких запросов, из ваших текстовых данных. Эта структура называется индексом; и процесс построения индекса из текста называется индексированием.
<br /><br />
Для разных задач разумно выбирать подходящий тип индекса. Например, индекс диска на основе дерева будет легко обновляться (т.е. вставлять новые документы в существующий индекс), но медленнее искать. Архитектура Sphinx позволяет внутренне использовать различные типы индексов (также иногда называются backends), реализовать которые сравнительно легко.
<br /><br />
Начиная с 1.10-бета, Sphinx предоставляет 2 разных бэкенда:  disk index backend и RT (realtime) index backend.
<br /><br />
Индексы дисков предназначены для обеспечения максимальной скорости индексирования и поиска, используя при этом как можно меньше RAM. Это реализовано за счет обновления текстовых индексов. Вы не можете обновить существующий документ или поэтапно добавить новый документ в индекс диска. Вы можете только перезагрузить весь индекс диска с нуля.
<br /><br />
Обратите внимание - обновлять атрибуты документа «на лету» возможно даже с дисковыми индексами.
<br /><br />
Это ограничение "rebuild only" на первый взгляд может выглядеть как большая проблема. Однако его можно очень часто обойти довольно простым образом - настраивая несколько дисковых индексов, выполняя поиск по ним и восстанавливая только часть последних измененных данных. Подробные сведения см. В разделе 3.11 «Обновления индексов».
<br /><br />
RT-индексы позволяют вам внедрять динамические обновления и инкрементные дополнения к полному текстовому индексу. RT означает «реальное время», и это действительно «soft realtime» с точки зрения записи. Это значит, что большинство изменений индекса становятся доступными для поиска с точностью до 1 миллисекунды или менее, но иногда могут задерживаться на несколько секунд. (Поиск по-прежнему будет работать даже во время этих задержек) Подробнее см. Главу 4 «Индексы реального времени».
<br /><br />
И последнее, но не менее важное: Sphinx поддерживает так называемые распределенные индексы (distributed indexes). По сравнению с дисковыми и RT-индексами они являются не реальным физическим бэкэндом, а скорее списками локальных или удаленных индексов, по которым можно искать прозрачно для приложения, при этом Sphinx выполняет все обязанности по отправке поисковых запросов на удаленные компьютеры в кластере, агрегирование наборов результатов, повторение неудачных запросов и даже выполнение некоторой балансировки нагрузки. См. Раздел 5.8 «Распределенный поиск» для обсуждения распределенных индексов.
<br /><br />
При необходимости может столько угодно индексов на файл конфигурации. Утилита indexer может переиндексировать либо все из них (если задана опция -all), либо определенное явно указанное подмножество. утилита searchd будет обслуживать все указанные индексы, а клиенты могут указывать, какие индексы искать во время выполнения.

<br /><br />

<h2>3.11 Обновление индексов в реальном времени</h2>
Существует два основных подхода к поддержанию полнотекстового содержимого индекса.
<br /><br />
<b>Обратите внимание, что оба этих подхода касаются задачи полнотекстовых обновлений данных, а не обновлений атрибутов. Быстрые обновления атрибутов поддерживаются с версии 0.9.8. Подробнее см. В описании вызова API-адресов UpdateAttributes.</b>
<br /><br />
Во-первых, вы можете использовать disk-based индексы, разбивать их вручную и периодически перестраивать небольшие разделы (так называемые «дельта»). Минимизируя размер обновлений, вы можете уменьшить среднюю задержку индексации до уровня 30-60 секунд. Этот подход был единственным, доступным в версиях 0.9.x. В огромных базах это действительно может быть самым эффективным. Подробнее см. Раздел 3.12 «Обновления индекса Delta».
<br /><br />
Во-вторых, версии 1.x (начиная с 1.10-бета) добавлена поддержка так называемых индексов реального времени (RT indexes), которые позволяют обновлять полнотекстовые данные «на лету». Обновления RT индексов могут отразиться в результатах поиска через 1-2 миллисекунды (0.001-0.002 сек). Однако индекс RT менее эффективен для индексирования огромных объемов данных. Подробнее см. Главу 4, Индексы реального времени.
